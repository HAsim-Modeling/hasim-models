DATA STRUCTURES

  Cache protocol messages passed throughout the hierarchy:

    * REQ_LOAD: Read request
        o exclusive flag: Shared (read-only) if false, write-intent if true
        o opaque value (Level-dependent value.  Each level may update the value
                        but must ultimately return the same value in a RSP_LOAD.)
    * RSP_LOAD
        o exclusive flag: Same as REQ_LOAD.
        o opaque value (from REQ_LOAD)
    * WB_INVAL: Write request
        o exclusive flag: CPU owns the line (may be dirty and exclusive).
        o dirty flag: Does the payload include dirty state?
        o toDir flag: Is the message a response to a request from a lower
          level cache?
    * FORCE_INVAL: Force writeback, if necessary. The response to FORCE_INVAL is
      a WB_INVAL with toDir set.
        o fromDir: Request from directory controller


NOTATION

  In the following discussion:
    - "o" prefix on a line represents a state transition
    - Message/channel notation: <type>/<channel>, e.g. WB_INVAL/2


CHANNELS

  Three channels maintain ordering.  Channels 0 and 2 travel from L1 toward
  the LLC.  Channel 2 is given higher priority than channel 0.  Channel 1
  travels from the LLC toward the L1.  

    0: REQ_LOAD
    1: RSP_LOAD, FORCE_INVAL [ may block when channel 2 full ]
    2: WB_INVAL [ never blocks ]


PROTOCOLS

L1I:

States (stable):
    * S: Present in this and, possibly, others.
    * I: Invalid.
States (transition):
    * FILL: Fill request outstanding.

Transitions:
    * Processor READ:
        * S: Immediate response HIT
        o FILL
          * If the request can be merged with the parent outstanding read
            then immediate response MISS.
          * If the request can NOT be merged then immediate response RETRY.
        o Not present:  Pick a victim.
          * No victim available:  Immediate response RETRY.
          o I -> FILL:
              REQ_LOAD/0 to L2 with not exclusive.
              Immediate response MISS.
          o S -> FILL:
              WB_INVAL/2 toDir false, dirty false, exclusive false.
              REQ_LOAD/0 to L2 with not exclusive.
              Immediate response MISS.
    * RSP_LOAD:
        * {S, I, Not present}: ERROR
        o FILL -> S:  Notify CPU fill complete
    * FORCE_INVAL:
        The I-cache currently sends no WB_INVAL response.  Doing so would force
        the L2 to wait for a response from both the I and D caches, which would
        complicate the algorithm.  Our run-time model never overwrites
        instructions, so timing of FORCE_INVAL/WB_INVAL isn't really critical.

        o S -> I
        o FILL: No change (Fill must not have been received yet by the LLC.
                           If it had, the RSP_LOAD would arrive before FORCE_INVAL.)
        o Not present: No change


L1D:

States (stable):
    * M: Present only here and dirty.
    * E: Present only here and clean.
    * S: Present in this and, possibly, others.
    * I: Invalid.
States (transition):
    * FILL_S: Fill request outstanding (for shared).
    * FILL_E: Fill request outstanding (for exclusive).
    * S_E: S to E transition

Transitions:
    * Processor READ:
        * {M, E, S, S_E}: Immediate response HIT
        o {FILL_S, FILL_E}
          * If the request can be merged with the parent outstanding read
            then immediate response MISS.
          * If the request can NOT be merged then immediate response RETRY.
        o Not present: Pick a victim.
          * No victim available:  Immediate response RETRY.
          o {M, E, S} -> FILL_S:
              WB_INVAL/2 toDir false, dirty if from M, exclusive if not from S.
              REQ_LOAD/0 to L2 with not exclusive.
              Immediate response MISS to CPU
          o I -> FILL_S:
              REQ_LOAD/0 to L2 with not exclusive.
              Immediate response MISS to CPU
          * Transition state: No action.
    * Processor WRITE:
        o M: Immediate response HIT
        o E -> M: Immediate response HIT
        o S -> S_E: REQ_LOAD/0 with exclusive to L2.
                    Immediate response RETRY
        o FILL_S -> FILL_E: REQ_LOAD/0 with exclusive to L2.
                            Immediate response RETRY
        * {FILL_E, S_E}: Immediate response RETRY
        o Not present (pick a victim):  All immediate response RETRY to CPU.
          * No victim available:  Immediate response RETRY.
          o {M, E, S} -> FILL_E:
              WB_INVAL/2 toDir false, dirty if from M, exclusive if not from S.
              REQ_LOAD/0 to L2 with exclusive.
          o I -> FILL_E:
              REQ_LOAD/0 to L2 with exclusive.
    * RSP_LOAD:
        o {M, E, S, I}: ERROR
        o FILL_S -> S: Notify CPU fill complete if load
        o FILL_E -> {exclusive ? E : S_E}: Notify CPU fill complete if load
        o S_E -> E: Error if RSP_LOAD ! exclusive,
                    Notify CPU fill complete if load
    * FORCE_INVAL:
        o {M, E, S} -> I:
            WB_INVAL/2 toDir copied from fromDir, dirty if from M,
                                                  exclusive if not from S.
        o {I, FILL_S, FILL_E}: No change
            WB_INVAL/2 toDir copied from fromDir, dirty false, exclusive false.
            (Line currently behaves as though it is invalid.  Fill request hasn't
             been received by the directory but will still complete, later.)
        o S_E -> FILL_E
            WB_INVAL/2 toDir copied from fromDir, dirty false, exclusive false.
            (Switching to FILL_E blocks future reads until the switch
             to exclusive.)


L2:

  Note that the L2 is non-inclusive and populated as a victim cache.
  A line may be present in the L1 without being present in the L2.
  All FORCE_INVAL messages from the LLC must first be forwarded to the L1.
  The L1 I-cache never responds to a FORCE_INVAL.  We use the response from
  the L1 D-cache as a proxy for both halves.

States (stable):
    * M: Present only here or L1 and dirty.
    * E: Present only here or L1 and clean.
    * S: Present in this and, possibly, others.
    * I: Invalid.

Transitions:
    * REQ_LOAD not exclusive:
        * {M, E, S}: Hit (RSP_LOAD/1)
        * I:
            Forward REQ_LOAD/0 to LLC.
    * REQ_LOAD exclusive:
        * {M, E}: Hit (RSP_LOAD/1)
        * I:
            Forward REQ_LOAD/0 to LLC.
    * WB_INVAL not toDir:
        * M: Done
        o E -> {dirty ? M : E}: Done
        * S: Done.  ERROR if dirty or if exclusive.
        o Not present:  Pick a victim
          * Eviction based on current state:
            * M
                WB_INVAL/2 toDir false, dirty true, exclusive true.
            * {E, S, I}: No action.
          o -> {M if dirty, E if only exclusive, otherwise S}
    * WB_INVAL toDir:
        o {M, E, S, I} -> I
            WB_INVAL/2 to LLC toDir true,
                              dirty copied and set if state was M,
                              exclusive copied and set if {M, E}.
            ERROR if in S and incoming request has exclusive.
    * RSP_LOAD:
        o S -> {S, E}: Exclusive set if response has exclusive bit set.
            RSP_LOAD/1 forward to L1.
        * All others: Do not add to cache.  (L2 is a victim cache.)
            RSP_LOAD/1 forward to L1.
    * FORCE_INVAL:
        * Forward FORCE_INVAL/1 to L1


LLC:

Flags:
    * Dirty: LLC way contains update not yet written to memory
States (stable):
    * L: Present only here.
    * LS: Present in this and, possibly, others in S state.
    * LM: Present in this and, possibly, modified in a private cache.
    * I: Invalid.
States (transition):
    * FILL_S: Fill request outstanding (for shared).
    * FILL_E: Fill request outstanding (for exclusive).
    * LM_L: LM to L transition

Transitions:
    * REQ_LOAD not exclusive:
        o {L, LS} -> LS: Immediate RSP_LOAD
        o LM -> LM_L: Send WB request to directory and keep REQ_LOAD
        o {FILL_S, FILL_E, LM_L}: Block
        o Not present (pick a victim and keep REQ_LOAD request):
          o L and dirty: WB_INVAL/0 toDir false, inval true, dirty true,
                         clear dirty
          o L and ! dirty -> FILL_S: REQ_LOAD/0 to mem with not exclusive
          o {LS, LM} -> LM_L: Send WB+INVAL request to directory
          o I -> FILL_S: REQ_LOAD/0 to mem with not exclusive
          o Transition state: Block
    * REQ_LOAD exclusive:
        o L -> LM: Immediate RSP_LOAD
        o {LS, LM} -> LM_L: Send WB+INVAL request to directory
        o {FILL_S, FILL_E, LM_L}: Block
        o Not present (pick a victim and keep REQ_LOAD request):
          o L and dirty: WB_INVAL/0 toDir false, inval true, dirty true,
                         clear dirty
          o L and ! dirty -> FILL_E: REQ_LOAD/0 to mem with not exclusive
          o {LS, LM} -> LM_L: Send WB+INVAL request to directory
          o I -> FILL_E: REQ_LOAD/0 to mem with not exclusive
          o Transition state: Block
    * Directory response WB or WB+INVAL
        o Not LM_L: ERROR
        o LM_L and dirty:  WB_INVAL/0 toDir false, inval false, dirty true,
                           clear dirty
        o LM_L and ! dirty -> L
    * WB_INVAL: Forward to directory
        o {L, I, FILL_S, FILL_E}: ERROR
        o LS: ERROR if dirty
        o LM -> (! inval ? LS : L): Set dirty if dirty
        o LM_L: Set dirty if dirty
    * RSP_LOAD:
        o {L, LS, LM, I, LM_L}: ERROR
        o FILL_S -> LS: RSP_LOAD forwarded to L2.
        o FILL_E -> LM: RSP_LOAD with exclusive forwarded to L2.
    * FORCE_INVAL: ERROR


Directory:

State:
  * Bit vector, one per L2.  On when data present in L2.
  * Active req flag

    * New FORCE_INVAL from LLC
      * All bits clear:  Send response to LLC
      * Not all clear: Set active req, Send FORCE_INVAL/1 to each L2
    * WB_INVAL: Update bit vector
      * Active req: If all clear send response to LLC
